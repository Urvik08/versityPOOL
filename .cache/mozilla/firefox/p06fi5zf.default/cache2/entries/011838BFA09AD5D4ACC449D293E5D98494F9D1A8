/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Latitude/longitude spherical geodesy formulae & scripts           (c) Chris Veness 2002-2015  */
/*   - www.movable-type.co.uk/scripts/latlong.html                                   MIT Licence  */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

'use strict';
if (typeof module!='undefined' && module.exports) var Dms = require('./dms'); // CommonJS (Node)


/**
 * Creates a LatLon point on the earth's surface at the specified latitude / longitude.
 *
 * @classdesc Tools for geodetic calculations
 * @requires Dms from 'dms.js'
 *
 * @constructor
 * @param {number} lat - Latitude in degrees.
 * @param {number} lon - Longitude in degrees.
 *
 * @example
 *     var p1 = new LatLon(52.205, 0.119);
 */
function LatLon(lat, lon) {
    // allow instantiation without 'new'
    if (!(this instanceof LatLon)) return new LatLon(lat, lon);

    this.lat = Number(lat);
    this.lon = Number(lon);
}


/**
 * Returns the distance from 'this' point to destination point (using haversine formula).
 *
 * @param   {LatLon} point - Latitude/longitude of destination point.
 * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).
 * @returns {number} Distance between this point and destination point, in same units as radius.
 *
 * @example
 *     var p1 = new LatLon(52.205, 0.119), p2 = new LatLon(48.857, 2.351);
 *     var d = p1.distanceTo(p2); // Number(d.toPrecision(4)): 404300
 */
LatLon.prototype.distanceTo = function(point, radius) {
    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');
    radius = (radius === undefined) ? 6371e3 : Number(radius);

    var R = radius;
    var œÜ1 = this.lat.toRadians(),  Œª1 = this.lon.toRadians();
    var œÜ2 = point.lat.toRadians(), Œª2 = point.lon.toRadians();
    var ŒîœÜ = œÜ2 - œÜ1;
    var ŒîŒª = Œª2 - Œª1;

    var a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
            Math.cos(œÜ1) * Math.cos(œÜ2) *
            Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    var d = R * c;

    return d;
};


/**
 * Returns the (initial) bearing from 'this' point to destination point.
 *
 * @param   {LatLon} point - Latitude/longitude of destination point.
 * @returns {number} Initial bearing in degrees from north.
 *
 * @example
 *     var p1 = new LatLon(52.205, 0.119), p2 = new LatLon(48.857, 2.351);
 *     var b1 = p1.bearingTo(p2); // b1.toFixed(1): 156.2
 */
LatLon.prototype.bearingTo = function(point) {
    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');

    var œÜ1 = this.lat.toRadians(), œÜ2 = point.lat.toRadians();
    var ŒîŒª = (point.lon-this.lon).toRadians();

    // see http://mathforum.org/library/drmath/view/55417.html
    var y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
    var x = Math.cos(œÜ1)*Math.sin(œÜ2) -
            Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(ŒîŒª);
    var Œ∏ = Math.atan2(y, x);

    return (Œ∏.toDegrees()+360) % 360;
};


/**
 * Returns final bearing arriving at destination destination point from 'this' point; the final bearing
 * will differ from the initial bearing by varying degrees according to distance and latitude.
 *
 * @param   {LatLon} point - Latitude/longitude of destination point.
 * @returns {number} Final bearing in degrees from north.
 *
 * @example
 *     var p1 = new LatLon(52.205, 0.119), p2 = new LatLon(48.857, 2.351);
 *     var b2 = p1.finalBearingTo(p2); // b2.toFixed(1): 157.9
 */
LatLon.prototype.finalBearingTo = function(point) {
    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');

    // get initial bearing from destination point to this point & reverse it by adding 180¬∞
    return ( point.bearingTo(this)+180 ) % 360;
};


/**
 * Returns the midpoint between 'this' point and the supplied point.
 *
 * @param   {LatLon} point - Latitude/longitude of destination point.
 * @returns {LatLon} Midpoint between this point and the supplied point.
 *
 * @example
 *     var p1 = new LatLon(52.205, 0.119), p2 = new LatLon(48.857, 2.351);
 *     var pMid = p1.midpointTo(p2); // pMid.toString(): 50.5363¬∞N, 001.2746¬∞E
 */
LatLon.prototype.midpointTo = function(point) {
    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');

    // see http://mathforum.org/library/drmath/view/51822.html for derivation

    var œÜ1 = this.lat.toRadians(), Œª1 = this.lon.toRadians();
    var œÜ2 = point.lat.toRadians();
    var ŒîŒª = (point.lon-this.lon).toRadians();

    var Bx = Math.cos(œÜ2) * Math.cos(ŒîŒª);
    var By = Math.cos(œÜ2) * Math.sin(ŒîŒª);

    var œÜ3 = Math.atan2(Math.sin(œÜ1)+Math.sin(œÜ2),
             Math.sqrt( (Math.cos(œÜ1)+Bx)*(Math.cos(œÜ1)+Bx) + By*By) );
    var Œª3 = Œª1 + Math.atan2(By, Math.cos(œÜ1) + Bx);

    return new LatLon(œÜ3.toDegrees(), (Œª3.toDegrees()+540)%360-180); // normalise to ‚àí180‚Ä¶+180¬∞
};


/**
 * Returns the destination point from 'this' point having travelled the given distance on the
 * given initial bearing (bearing normally varies around path followed).
 *
 * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).
 * @param   {number} bearing - Initial bearing in degrees from north.
 * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).
 * @returns {LatLon} Destination point.
 *
 * @example
 *     var p1 = new LatLon(51.4778, -0.0015);
 *     var p2 = p1.destinationPoint(7794, 300.7); // p2.toString(): 51.5135¬∞N, 000.0983¬∞W
 */
LatLon.prototype.destinationPoint = function(distance, bearing, radius) {
    radius = (radius === undefined) ? 6371e3 : Number(radius);

    // see http://williams.best.vwh.net/avform.htm#LL

    var Œ¥ = Number(distance) / radius; // angular distance in radians
    var Œ∏ = Number(bearing).toRadians();

    var œÜ1 = this.lat.toRadians();
    var Œª1 = this.lon.toRadians();

    var œÜ2 = Math.asin( Math.sin(œÜ1)*Math.cos(Œ¥) +
                        Math.cos(œÜ1)*Math.sin(Œ¥)*Math.cos(Œ∏) );
    var Œª2 = Œª1 + Math.atan2(Math.sin(Œ∏)*Math.sin(Œ¥)*Math.cos(œÜ1),
                             Math.cos(Œ¥)-Math.sin(œÜ1)*Math.sin(œÜ2));

    return new LatLon(œÜ2.toDegrees(), (Œª2.toDegrees()+540)%360-180); // normalise to ‚àí180‚Ä¶+180¬∞
};


/**
 * Returns the point of intersection of two paths defined by point and bearing.
 *
 * @param   {LatLon} p1 - First point.
 * @param   {number} brng1 - Initial bearing from first point.
 * @param   {LatLon} p2 - Second point.
 * @param   {number} brng2 - Initial bearing from second point.
 * @returns {LatLon} Destination point (null if no unique intersection defined).
 *
 * @example
 *     var p1 = LatLon(51.8853, 0.2545), brng1 = 108.547;
 *     var p2 = LatLon(49.0034, 2.5735), brng2 =  32.435;
 *     var pInt = LatLon.intersection(p1, brng1, p2, brng2); // pInt.toString(): 50.9078¬∞N, 004.5084¬∞E
 */
LatLon.intersection = function(p1, brng1, p2, brng2) {
    if (!(p1 instanceof LatLon)) throw new TypeError('p1 is not LatLon object');
    if (!(p2 instanceof LatLon)) throw new TypeError('p2 is not LatLon object');

    // see http://williams.best.vwh.net/avform.htm#Intersection

    var œÜ1 = p1.lat.toRadians(), Œª1 = p1.lon.toRadians();
    var œÜ2 = p2.lat.toRadians(), Œª2 = p2.lon.toRadians();
    var Œ∏13 = Number(brng1).toRadians(), Œ∏23 = Number(brng2).toRadians();
    var ŒîœÜ = œÜ2-œÜ1, ŒîŒª = Œª2-Œª1;

    var Œ¥12 = 2*Math.asin( Math.sqrt( Math.sin(ŒîœÜ/2)*Math.sin(ŒîœÜ/2) +
        Math.cos(œÜ1)*Math.cos(œÜ2)*Math.sin(ŒîŒª/2)*Math.sin(ŒîŒª/2) ) );
    if (Œ¥12 == 0) return null;

    // initial/final bearings between points
    var Œ∏1 = Math.acos( ( Math.sin(œÜ2) - Math.sin(œÜ1)*Math.cos(Œ¥12) ) /
                        ( Math.sin(Œ¥12)*Math.cos(œÜ1) ) );
    if (isNaN(Œ∏1)) Œ∏1 = 0; // protect against rounding
    var Œ∏2 = Math.acos( ( Math.sin(œÜ1) - Math.sin(œÜ2)*Math.cos(Œ¥12) ) /
                        ( Math.sin(Œ¥12)*Math.cos(œÜ2) ) );

    var Œ∏12, Œ∏21;
    if (Math.sin(Œª2-Œª1) > 0) {
        Œ∏12 = Œ∏1;
        Œ∏21 = 2*Math.PI - Œ∏2;
    } else {
        Œ∏12 = 2*Math.PI - Œ∏1;
        Œ∏21 = Œ∏2;
    }

    var Œ±1 = (Œ∏13 - Œ∏12 + Math.PI) % (2*Math.PI) - Math.PI; // angle 2-1-3
    var Œ±2 = (Œ∏21 - Œ∏23 + Math.PI) % (2*Math.PI) - Math.PI; // angle 1-2-3

    if (Math.sin(Œ±1)==0 && Math.sin(Œ±2)==0) return null; // infinite intersections
    if (Math.sin(Œ±1)*Math.sin(Œ±2) < 0) return null;      // ambiguous intersection

    //Œ±1 = Math.abs(Œ±1);
    //Œ±2 = Math.abs(Œ±2);
    // ... Ed Williams takes abs of Œ±1/Œ±2, but seems to break calculation?

    var Œ±3 = Math.acos( -Math.cos(Œ±1)*Math.cos(Œ±2) +
                         Math.sin(Œ±1)*Math.sin(Œ±2)*Math.cos(Œ¥12) );
    var Œ¥13 = Math.atan2( Math.sin(Œ¥12)*Math.sin(Œ±1)*Math.sin(Œ±2),
                          Math.cos(Œ±2)+Math.cos(Œ±1)*Math.cos(Œ±3) );
    var œÜ3 = Math.asin( Math.sin(œÜ1)*Math.cos(Œ¥13) +
                        Math.cos(œÜ1)*Math.sin(Œ¥13)*Math.cos(Œ∏13) );
    var ŒîŒª13 = Math.atan2( Math.sin(Œ∏13)*Math.sin(Œ¥13)*Math.cos(œÜ1),
                           Math.cos(Œ¥13)-Math.sin(œÜ1)*Math.sin(œÜ3) );
    var Œª3 = Œª1 + ŒîŒª13;

    return new LatLon(œÜ3.toDegrees(), (Œª3.toDegrees()+540)%360-180); // normalise to ‚àí180‚Ä¶+180¬∞
};


/**
 * Returns (signed) distance from ‚Äòthis‚Äô point to great circle defined by start-point and end-point.
 *
 * @param   {LatLon} pathStart - Start point of great circle path.
 * @param   {LatLon} pathEnd - End point of great circle path.
 * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).
 * @returns {number} Distance to great circle (-ve if to left, +ve if to right of path).
 *
 * @example
 *   var pCurrent = new LatLon(53.2611, -0.7972);
 *   var p1 = new LatLon(53.3206, -1.7297), p2 = new LatLon(53.1887, 0.1334);
 *   var d = pCurrent.crossTrackDistanceTo(p1, p2);  // Number(d.toPrecision(4)): -307.5
 */
LatLon.prototype.crossTrackDistanceTo = function(pathStart, pathEnd, radius) {
    if (!(pathStart instanceof LatLon)) throw new TypeError('pathStart is not LatLon object');
    if (!(pathEnd instanceof LatLon)) throw new TypeError('pathEnd is not LatLon object');
    radius = (radius === undefined) ? 6371e3 : Number(radius);

    var Œ¥13 = pathStart.distanceTo(this, radius)/radius;
    var Œ∏13 = pathStart.bearingTo(this).toRadians();
    var Œ∏12 = pathStart.bearingTo(pathEnd).toRadians();

    var dxt = Math.asin( Math.sin(Œ¥13) * Math.sin(Œ∏13-Œ∏12) ) * radius;

    return dxt;
};


/**
 * Returns maximum latitude reached when travelling on a great circle on given bearing from this
 * point ('Clairaut's formula'). Negate the result for the minimum latitude (in the Southern
 * hemisphere).
 *
 * The maximum latitude is independent of longitude; it will be the same for all points on a given
 * latitude.
 *
 * @param {number} bearing - Initial bearing.
 * @param {number} latitude - Starting latitude.
 */
LatLon.prototype.maxLatitude = function(bearing) {
    var Œ∏ = Number(bearing).toRadians();

    var œÜ = this.lat.toRadians();

    var œÜMax = Math.acos(Math.abs(Math.sin(Œ∏)*Math.cos(œÜ)));

    return œÜMax.toDegrees();
};


/**
 * Returns the pair of meridians at which a great circle defined by two points crosses the given
 * latitude. If the great circle doesn't reach the given latitude, null is returned.
 *
 * @param {LatLon} point1 - First point defining great circle.
 * @param {LatLon} point2 - Second point defining great circle.
 * @param {number} latitude - Latitude crossings are to be determined for.
 * @returns { { lon1, lon2 } } | null
 */
LatLon.crossingParallels = function(point1, point2, latitude) {
    var œÜ = Number(latitude).toRadians();

    var œÜ1 = point1.lat.toRadians();
    var Œª1 = point1.lon.toRadians();
    var œÜ2 = point2.lat.toRadians();
    var Œª2 = point2.lon.toRadians();

    var ŒîŒª = Œª2 - Œª1;

    var x = Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(œÜ) * Math.sin(ŒîŒª);
    var y = Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(œÜ) * Math.cos(ŒîŒª) - Math.cos(œÜ1) * Math.sin(œÜ2) * Math.cos(œÜ);
    var z = Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(œÜ) * Math.sin(ŒîŒª);

    if (z*z > x*x + y*y) return null; // great circle doesn't reach latitude

    var Œªm = Math.atan2(-y, x);                  // longitude at max latitude
    var ŒîŒªi = Math.acos(z / Math.sqrt(x*x+y*y)); // ŒîŒª from Œªm to intersection points

    var Œªi1 = Œª1 + Œªm - ŒîŒªi;
    var Œªi2 = Œª1 + Œªm + ŒîŒªi;

    return { lon1: (Œªi1.toDegrees()+540)%360-180, lon2: (Œªi2.toDegrees()+540)%360-180 }; // normalise to ‚àí180‚Ä¶+180¬∞
};


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/**
 * Returns the distance travelling from 'this' point to destination point along a rhumb line.
 *
 * @param   {LatLon} point - Latitude/longitude of destination point.
 * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).
 * @returns {number} Distance in km between this point and destination point (same units as radius).
 *
 * @example
 *     var p1 = new LatLon(51.127, 1.338), p2 = new LatLon(50.964, 1.853);
 *     var d = p1.distanceTo(p2); // Number(d.toPrecision(4)): 40310
 */
LatLon.prototype.rhumbDistanceTo = function(point, radius) {
    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');
    radius = (radius === undefined) ? 6371e3 : Number(radius);

    // see http://williams.best.vwh.net/avform.htm#Rhumb

    var R = radius;
    var œÜ1 = this.lat.toRadians(), œÜ2 = point.lat.toRadians();
    var ŒîœÜ = œÜ2 - œÜ1;
    var ŒîŒª = Math.abs(point.lon-this.lon).toRadians();
    // if dLon over 180¬∞ take shorter rhumb line across the anti-meridian:
    if (Math.abs(ŒîŒª) > Math.PI) ŒîŒª = ŒîŒª>0 ? -(2*Math.PI-ŒîŒª) : (2*Math.PI+ŒîŒª);

    // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'
    // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it
    var Œîœà = Math.log(Math.tan(œÜ2/2+Math.PI/4)/Math.tan(œÜ1/2+Math.PI/4));
    var q = Math.abs(Œîœà) > 10e-12 ? ŒîœÜ/Œîœà : Math.cos(œÜ1);

    // distance is pythagoras on 'stretched' Mercator projection
    var Œ¥ = Math.sqrt(ŒîœÜ*ŒîœÜ + q*q*ŒîŒª*ŒîŒª); // angular distance in radians
    var dist = Œ¥ * R;

    return dist;
};


/**
 * Returns the bearing from 'this' point to destination point along a rhumb line.
 *
 * @param   {LatLon} point - Latitude/longitude of destination point.
 * @returns {number} Bearing in degrees from north.
 *
 * @example
 *     var p1 = new LatLon(51.127, 1.338), p2 = new LatLon(50.964, 1.853);
 *     var d = p1.rhumbBearingTo(p2); // d.toFixed(1): 116.7
 */
LatLon.prototype.rhumbBearingTo = function(point) {
    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');

    var œÜ1 = this.lat.toRadians(), œÜ2 = point.lat.toRadians();
    var ŒîŒª = (point.lon-this.lon).toRadians();
    // if dLon over 180¬∞ take shorter rhumb line across the anti-meridian:
    if (Math.abs(ŒîŒª) > Math.PI) ŒîŒª = ŒîŒª>0 ? -(2*Math.PI-ŒîŒª) : (2*Math.PI+ŒîŒª);

    var Œîœà = Math.log(Math.tan(œÜ2/2+Math.PI/4)/Math.tan(œÜ1/2+Math.PI/4));

    var Œ∏ = Math.atan2(ŒîŒª, Œîœà);

    return (Œ∏.toDegrees()+360) % 360;
};


/**
 * Returns the destination point having travelled along a rhumb line from 'this' point the given
 * distance on the  given bearing.
 *
 * @param   {number} distance - Distance travelled, in same units as earth radius (default: metres).
 * @param   {number} bearing - Bearing in degrees from north.
 * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).
 * @returns {LatLon} Destination point.
 *
 * @example
 *     var p1 = new LatLon(51.127, 1.338);
 *     var p2 = p1.rhumbDestinationPoint(40300, 116.7); // p2.toString(): 50.9642¬∞N, 001.8530¬∞E
 */
LatLon.prototype.rhumbDestinationPoint = function(distance, bearing, radius) {
    radius = (radius === undefined) ? 6371e3 : Number(radius);

    var Œ¥ = Number(distance) / radius; // angular distance in radians
    var œÜ1 = this.lat.toRadians(), Œª1 = this.lon.toRadians();
    var Œ∏ = Number(bearing).toRadians();

    var ŒîœÜ = Œ¥ * Math.cos(Œ∏);
    var œÜ2 = œÜ1 + ŒîœÜ;

    // check for some daft bugger going past the pole, normalise latitude if so
    if (Math.abs(œÜ2) > Math.PI/2) œÜ2 = œÜ2>0 ? Math.PI-œÜ2 : -Math.PI-œÜ2;

    var Œîœà = Math.log(Math.tan(œÜ2/2+Math.PI/4)/Math.tan(œÜ1/2+Math.PI/4));
    var q = Math.abs(Œîœà) > 10e-12 ? ŒîœÜ / Œîœà : Math.cos(œÜ1); // E-W course becomes ill-conditioned with 0/0

    var ŒîŒª = Œ¥*Math.sin(Œ∏)/q;
    var Œª2 = Œª1 + ŒîŒª;

    return new LatLon(œÜ2.toDegrees(), (Œª2.toDegrees()+540)%360-180); // normalise to ‚àí180‚Ä¶+180¬∞
};


/**
 * Returns the loxodromic midpoint (along a rhumb line) between 'this' point and second point.
 *
 * @param   {LatLon} point - Latitude/longitude of second point.
 * @returns {LatLon} Midpoint between this point and second point.
 *
 * @example
 *     var p1 = new LatLon(51.127, 1.338), p2 = new LatLon(50.964, 1.853);
 *     var p2 = p1.rhumbMidpointTo(p2); // p2.toString(): 51.0455¬∞N, 001.5957¬∞E
 */
LatLon.prototype.rhumbMidpointTo = function(point) {
    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');

    // http://mathforum.org/kb/message.jspa?messageID=148837

    var œÜ1 = this.lat.toRadians(), Œª1 = this.lon.toRadians();
    var œÜ2 = point.lat.toRadians(), Œª2 = point.lon.toRadians();

    if (Math.abs(Œª2-Œª1) > Math.PI) Œª1 += 2*Math.PI; // crossing anti-meridian

    var œÜ3 = (œÜ1+œÜ2)/2;
    var f1 = Math.tan(Math.PI/4 + œÜ1/2);
    var f2 = Math.tan(Math.PI/4 + œÜ2/2);
    var f3 = Math.tan(Math.PI/4 + œÜ3/2);
    var Œª3 = ( (Œª2-Œª1)*Math.log(f3) + Œª1*Math.log(f2) - Œª2*Math.log(f1) ) / Math.log(f2/f1);

    if (!isFinite(Œª3)) Œª3 = (Œª1+Œª2)/2; // parallel of latitude

    return new LatLon(œÜ3.toDegrees(), (Œª3.toDegrees()+540)%360-180); // normalise to ‚àí180‚Ä¶+180¬∞
};


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */


/**
 * Returns a string representation of 'this' point, formatted as degrees, degrees+minutes, or
 * degrees+minutes+seconds.
 *
 * @param   {string} [format=dms] - Format point as 'd', 'dm', 'dms'.
 * @param   {number} [dp=0|2|4] - Number of decimal places to use - default 0 for dms, 2 for dm, 4 for d.
 * @returns {string} Comma-separated latitude/longitude.
 */
LatLon.prototype.toString = function(format, dp) {
    if (format === undefined) format = 'dms';

    return Dms.toLat(this.lat, format, dp) + ', ' + Dms.toLon(this.lon, format, dp);
};


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */


/** Extend Number object with method to convert numeric degrees to radians */
if (Number.prototype.toRadians === undefined) {
    Number.prototype.toRadians = function() { return this * Math.PI / 180; };
}


/** Extend Number object with method to convert radians to numeric (signed) degrees */
if (Number.prototype.toDegrees === undefined) {
    Number.prototype.toDegrees = function() { return this * 180 / Math.PI; };
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
if (typeof module != 'undefined' && module.exports) module.exports = LatLon; // CommonJS (Node)
if (typeof define == 'function' && define.amd) define(['Dms'], function() { return LatLon; }); // AMD
π¥≠Œôè      V§WSV§WS<x&V´áä   E:http://www.movable-type.co.uk/scripts/js/geodesy/latlon-spherical.js necko:classified 1 request-method GET response-head HTTP/1.1 200 OK
Date: Sun, 24 Jan 2016 04:47:11 GMT
Server: Apache
Last-Modified: Mon, 30 Nov 2015 16:10:12 GMT
Etag: "16088703-4d1a-525c4469c0100"
Accept-Ranges: bytes
Content-Length: 19738
Content-Type: application/javascript
 uncompressed-len 0   M